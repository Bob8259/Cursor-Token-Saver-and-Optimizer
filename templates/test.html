<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Complex Test Page</title>
    <style>
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background-color: #1a1a1a; color: #e0e0e0; margin: 0; padding: 20px; }
        .container { max-width: 1000px; margin: 0 auto; }
        .card { background: #2d2d2d; border-radius: 8px; padding: 20px; margin-bottom: 20px; box-shadow: 0 4px 6px rgba(0,0,0,0.3); }
        h1, h2 { color: #4CAF50; }
        .grid { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; }
        canvas { background: #fff; border-radius: 4px; }
        .code-block { background: #000; padding: 15px; border-radius: 4px; overflow-x: auto; font-family: 'Courier New', Courier, monospace; }
        .status-badge { display: inline-block; padding: 5px 10px; border-radius: 20px; background: #4CAF50; color: white; font-size: 0.8em; }
    </style>
</head>
<body>
    <div class="container">
        <h1>AI Coding Ability Test Dashboard</h1>
        <p>Server Time: {{ server_time }} <span class="status-badge">Live</span></p>

        <div class="grid">
            <div class="card">
                <h2>Live Physics Sandbox</h2>
                <div style="position: relative;">
                    <canvas id="physicsCanvas" style="display: block; width: 100%; height: 400px; background: #1a1a1a; border-radius: 4px;"></canvas>
                    <div id="perfMonitor" style="position: absolute; top: 10px; left: 10px; background: rgba(0,0,0,0.7); color: #0f0; padding: 10px; font-family: monospace; pointer-events: none; border-radius: 4px;">
                        FPS: <span id="fpsDisplay">0</span><br>
                        Worker Latency: <span id="latencyDisplay">0</span> ms
                    </div>
                    <div style="margin-top: 10px;">
                        <label style="display: flex; align-items: center; cursor: pointer;">
                            <input type="checkbox" id="chaosToggle" style="margin-right: 10px;">
                            <span>Chaos Mode (500 Particles)</span>
                        </label>
                    </div>
                </div>
            </div>
            <div class="card">
                <h2>Recursive Data Processing</h2>
                <p>Fibonacci Sequence (Server-side Computed):</p>
                <div class="code-block">
                    {{ fib_sequence | join(', ') }}
                </div>
                <p style="margin-top: 20px;">Matrix Multiplication (Client-side):</p>
                <div id="matrixResult" class="code-block"></div>
            </div>
        </div>

        <div class="card">
            <h2>Dynamic Data Table</h2>
            <div style="max-height: 300px; overflow-y: auto;">
                <table style="width: 100%; border-collapse: collapse;">
                    <thead>
                        <tr style="text-align: left; border-bottom: 1px solid #444;">
                            <th>Index</th>
                            <th>X-Value</th>
                            <th>Y-Value (Computed)</th>
                        </tr>
                    </thead>
                    <tbody>
                        {% for pt in data_points %}
                        <tr style="border-bottom: 1px solid #333;">
                            <td>{{ loop.index }}</td>
                            <td>{{ pt.x }}</td>
                            <td>{{ pt.y }}</td>
                        </tr>
                        {% endfor %}
                    </tbody>
                </table>
            </div>
        </div>
    </div>

    <script>
        // Physics Sandbox Implementation
        const canvas = document.getElementById('physicsCanvas');
        const ctx = canvas.getContext('2d');
        const perfMonitor = {
            fps: document.getElementById('fpsDisplay'),
            latency: document.getElementById('latencyDisplay'),
            lastFrameTime: performance.now(),
            frameCount: 0,
            lastFpsUpdate: performance.now()
        };
        
        let worker;

        function resizeCanvas() {
            canvas.width = canvas.clientWidth;
            canvas.height = canvas.clientHeight;
            if (worker) {
                worker.postMessage({ type: 'resize', width: canvas.width, height: canvas.height });
            }
        }
        window.addEventListener('resize', resizeCanvas);
        
        const workerCode = `
            let particles = [];
            const gravity = 0.5;
            const friction = 0.99;
            let width = 0;
            let height = 0;
            
            function initParticles(count, w, h) {
                width = w;
                height = h;
                particles = [];
                for (let i = 0; i < count; i++) {
                    particles.push({
                        x: Math.random() * (width - 20) + 10,
                        y: Math.random() * (height - 20) + 10,
                        vx: (Math.random() - 0.5) * 10,
                        vy: (Math.random() - 0.5) * 10,
                        radius: Math.random() * 5 + 5,
                        color: 'hsl(' + Math.random() * 360 + ', 70%, 50%)',
                        mass: 1
                    });
                }
            }

            function resolveCollision(p1, p2) {
                const dx = p2.x - p1.x;
                const dy = p2.y - p1.y;
                const distance = Math.sqrt(dx * dx + dy * dy);

                if (distance < p1.radius + p2.radius) {
                    const nx = dx / distance;
                    const ny = dy / distance;
                    const dvx = p2.vx - p1.vx;
                    const dvy = p2.vy - p1.vy;
                    const velAlongNormal = dvx * nx + dvy * ny;

                    if (velAlongNormal > 0) return;

                    const restitution = 0.9;
                    const j = -(1 + restitution) * velAlongNormal;
                    const impulse = j / 2;

                    p1.vx -= impulse * nx;
                    p1.vy -= impulse * ny;
                    p2.vx += impulse * nx;
                    p2.vy += impulse * ny;
                    
                    const overlap = (p1.radius + p2.radius - distance) / 2;
                    p1.x -= overlap * nx;
                    p1.y -= overlap * ny;
                    p2.x += overlap * nx;
                    p2.y += overlap * ny;
                }
            }

            self.onmessage = function(e) {
                const { type, data } = e.data;
                
                if (type === 'init' || type === 'reset') {
                    initParticles(data.count, data.width, data.height);
                } else if (type === 'resize') {
                    width = data.width;
                    height = data.height;
                } else if (type === 'step') {
                    const start = performance.now();
                    
                    for (let i = 0; i < particles.length; i++) {
                        let p = particles[i];
                        p.vy += gravity;
                        p.vx *= friction;
                        p.vy *= friction;
                        p.x += p.vx;
                        p.y += p.vy;

                        if (p.x - p.radius < 0) {
                            p.x = p.radius;
                            p.vx *= -0.8;
                        } else if (p.x + p.radius > width) {
                            p.x = width - p.radius;
                            p.vx *= -0.8;
                        }
                        
                        if (p.y - p.radius < 0) {
                            p.y = p.radius;
                            p.vy *= -0.8;
                        } else if (p.y + p.radius > height) {
                            p.y = height - p.radius;
                            p.vy *= -0.8;
                        }
                    }

                    for (let i = 0; i < particles.length; i++) {
                        for (let j = i + 1; j < particles.length; j++) {
                            resolveCollision(particles[i], particles[j]);
                        }
                    }
                    
                    const duration = performance.now() - start;
                    self.postMessage({ type: 'update', particles: particles, duration: duration, timestamp: data.timestamp });
                }
            };
        `;

        const blob = new Blob([workerCode], { type: 'application/javascript' });
        worker = new Worker(URL.createObjectURL(blob));
        
        resizeCanvas();
        worker.postMessage({ 
            type: 'init', 
            data: { count: 50, width: canvas.width, height: canvas.height } 
        });

        document.getElementById('chaosToggle').addEventListener('change', (e) => {
            const count = e.target.checked ? 500 : 50;
            worker.postMessage({ 
                type: 'reset', 
                data: { count: count, width: canvas.width, height: canvas.height } 
            });
        });

        function loop() {
            const now = performance.now();
            perfMonitor.frameCount++;
            if (now - perfMonitor.lastFpsUpdate >= 1000) {
                perfMonitor.fps.innerText = perfMonitor.frameCount;
                perfMonitor.frameCount = 0;
                perfMonitor.lastFpsUpdate = now;
            }
            worker.postMessage({ type: 'step', data: { timestamp: now } });
            requestAnimationFrame(loop);
        }

        worker.onmessage = function(e) {
            const { type, particles, duration } = e.data;
            if (type === 'update') {
                perfMonitor.latency.innerText = duration.toFixed(2);
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                for (const p of particles) {
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
                    ctx.fillStyle = p.color;
                    ctx.fill();
                    ctx.closePath();
                }
            }
        };

        loop();

        // Complex Client-side logic: Matrix Multiplication
        function multiplyMatrices(m1, m2) {
            const result = [];
            for (let i = 0; i < m1.length; i++) {
                result[i] = [];
                for (let j = 0; j < m2[0].length; j++) {
                    let sum = 0;
                    for (let k = 0; k < m1[0].length; k++) {
                        sum += m1[i][k] * m2[k][j];
                    }
                    result[i][j] = sum;
                }
            }
            return result;
        }

        const m1 = [[1, 2], [3, 4]];
        const m2 = [[5, 6], [7, 8]];
        const res = multiplyMatrices(m1, m2);
        document.getElementById('matrixResult').innerText = JSON.stringify(res);
    </script>
</body>
</html>
